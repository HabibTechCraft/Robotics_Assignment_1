{"mode":"Text","hardwareTarget":"brain","textContent":"#Dynamic Wall Maze Solution in Python\n\nimport math\nimport random\nfrom vexcode_vr import *\nfrom collections import deque \n\nbrain=Brain()\ndrivetrain = Drivetrain(\"drivetrain\", 0)\npen = Pen(\"pen\", 8)\npen.set_pen_width(THIN)\nleft_bumper = Bumper(\"leftBumper\", 2)\nright_bumper = Bumper(\"rightBumper\", 3)\nfront_eye = EyeSensor(\"frontEye\", 4)\ndown_eye = EyeSensor(\"downEye\", 5)\nfront_distance = Distance(\"frontdistance\", 6)\ndistance = front_distance\nmagnet = Electromagnet(\"magnet\", 7)\nlocation = Location(\"location\", 9)\n\n# Global variables for tracking the robot's path\npath_taken = [] \nvisited = set()\nvisited_cells = []\n\n# Constants\nSTART_POS = (130, -900)\nCELL_SIZE = 250\n\n# Retrieves current position of the robot and returns co-ordinates in MM\ndef get_current_position():\n    x = location.position(X, MM)\n    y = location.position(Y, MM)\n    return (int(x), int(y))\n\n# Sets the drivetrain speed for both movement and turning\ndef set_speed():\n    drivetrain.set_drive_velocity(100, PERCENT)\n    drivetrain.set_turn_velocity(100, PERCENT)\n\n# Moves the robot forward by 25mm also by a cellsize as the whole maze was divided into cells \n# with size of 25x25 to get the co-ordinates of the robot on the move\ndef move_forward():\n    drivetrain.drive_for(FORWARD, CELL_SIZE, MM)\n    path_taken.append(('forward', 1))\n\ndef turn_left():\n    drivetrain.turn_for(LEFT, 90, DEGREES)\n    path_taken.append(('turn_left', 90))\n\ndef turn_right():\n    drivetrain.turn_for(RIGHT, 90, DEGREES)\n    path_taken.append(('turn_right', 90))\n\n# Helps to mark the path covered by the robot\ndef mark_path():\n      pen.move(DOWN)\n      pen.set_pen_color(BLACK)\n\n# Step 1 Escaping the Maze\n# Uses Wall following algorithm specifically Left Hand Rule to find the quickest way possible for escape\ndef Escape_maze():\n    set_speed()\n    while not down_eye.detect(RED):\n        pen.move(DOWN)\n        pen.set_pen_width(THIN)\n        pen.set_pen_color(GREEN)\n\n        if front_eye.detect(RED):\n            turn_left()\n        if not front_eye.detect(RED):\n            move_forward()\n            turn_right()\n\n# Step 2 Returning back to home\n# This function assists robot to get back to the starting point by reversing the recorded path\ndef return_home(path_taken):\n\n    set_speed()\n    drivetrain.turn_for(LEFT, 180, DEGREES)\n    for move in reversed(path_taken):\n        action, value = move\n        if action == 'forward':\n            drivetrain.drive_for(FORWARD, 250, MM)\n        elif action == 'turn_left':\n            drivetrain.turn_for(RIGHT, 90, DEGREES)\n        elif action == 'turn_right':\n            drivetrain.turn_for(LEFT, 90, DEGREES)\n    return\n\n# Step3 Mapping the maze\n# Uses Breadth-First algorithm to explore the maze and do the mapping till the exit point.\ndef BFS_MAP():\n    set_speed()\n    start_pos = get_current_position()\n    visited.add(start_pos)\n    visited_cells.append(start_pos)\n    queue = deque([start_pos])\n    brain.print(\"Started Cell: \" + str(start_pos))\n    brain.new_line()\n    \n    while queue:\n        current_pos = queue.popleft()\n        mark_path()\n\n        for direction in ['forward', 'left', 'right']:\n            if front_eye.detect(RED): # If robot sees a wall in front, will take a left turn or else will keep moving forward\n                turn_left()\n            else:\n                move_forward()\n                new_pos = get_current_position() \n                \n# Only stores new positions/ coordinates (X, Y) to create a map\n                if new_pos not in visited:\n                    visited.add(new_pos)\n                    visited_cells.append(new_pos)\n                    queue.append(new_pos)\n                    brain.print(\"Visited Cell: \" + str(new_pos))\n                    brain.new_line()\n                turn_right()\n\n# If end of maze is reached, robot will stop exploring as the quickest way can be predicted \n        if down_eye.detect(RED): \n            return\n\n        if not queue:\n            return\n   \n            if down_eye.detect(RED):\n                return       \n\n# Uses BFS to find a shortest path from starting point to exit\ndef find_shortest_path(start, end):\n    queue = deque([(start, [])])\n    visited = set()\n    visited.add(start)\n\n    while queue:\n        current_pos, path = queue.popleft()\n\n        if current_pos == end:\n            return path\n\n        for direction in ['forward', 'left', 'right']:\n            if direction == 'forward':\n                move_forward()\n            elif direction == 'left':\n                turn_left()\n            elif direction == 'right':\n                turn_right()\n            new_pos = get_current_position()\n\n            if new_pos not in visited:\n                visited.add(new_pos)\n                new_path = path + [direction]\n                queue.append((new_pos, new_path))\n\n    return None\n\n# Main function that runs when the program and controls the robotâ€™s movement, mapping, and navigation.\n\ndef Main():\n    set_speed()\n    #Escape_maze()\n    #return_home(path_taken)\n    BFS_MAP()\n\n    END_POS = get_current_position() # Get the final position after mapping\n    brain.print(\"End Position: \" + str(END_POS))\n    # Calculates the shortest path\n    shortest_path = find_shortest_path(START_POS, END_POS)\n    \n    if shortest_path:\n        brain.print(\"Shortest Path: \" + str(shortest_path))\n        for move in shortest_path:\n            if move == 'forward':\n                move_forward()\n            elif move == 'left':\n                turn_left()\n            elif move == 'right':\n                turn_right()\n            \n            if get_current_position() == END_POS:\n                brain.print(\"Reached end position.\")\n                return\n    else:\n        brain.print(\"No path found\")\n  \nstop_project()\n\nvr_thread(Main)","textLanguage":"python","robotConfig":[],"slot":0,"platform":"PG","sdkVersion":"20240802.15.00.00","appVersion":"4.0.8","minVersion":"3.0.0","fileFormat":"2.0.0","targetBrainGen":"First","v5SoundsEnabled":false,"playground":"DynamicWallMaze","robotModel":"vr"}